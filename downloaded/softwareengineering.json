[
  {
    "score": 2651,
    "title": "A tsunami is coming",
    "selftext": "TLDR: LLMs are a tsunami transforming software development from analysis to testing. Ride that wave or die in it.\n\nI have been in IT since 1969. I have seen this before. I’ve heard the scoffing, the sneers, the rolling eyes when something new comes along that threatens to upend the way we build software. It happened when compilers for COBOL, Fortran, and later C began replacing the laborious hand-coding of assembler. Some developers—myself included, in my younger days—would say, “This is for the lazy and the incompetent. Real programmers write everything by hand.” We sneered as a tsunami rolled in (high-level languages delivered at least a 3x developer productivity increase over assembler), and many drowned in it. The rest adapted and survived. There was a time when databases were dismissed in similar terms: “Why trust a slow, clunky system to manage data when I can craft perfect ISAM files by hand?” And yet the surge of database technology reshaped entire industries, sweeping aside those who refused to adapt. (See: Computer: A History of the Information Machine (Ceruzzi, 3rd ed.) for historical context on the evolution of programming practices.)\n\nNow, we face another tsunami: Large Language Models, or LLMs, that will trigger a fundamental shift in how we analyze, design, and implement software. LLMs can generate code, explain APIs, suggest architectures, and identify security flaws—tasks that once took battle-scarred developers hours or days. Are they perfect? Of course not. Just like the early compilers weren’t perfect. Just like the first relational databases (relational theory notwithstanding—see Codd, 1970), it took time to mature.\n\nPerfection isn’t required for a tsunami to destroy a city; only unstoppable force.\n\nThis new tsunami is about more than coding. It’s about transforming the entire software development lifecycle—from the earliest glimmers of requirements and design through the final lines of code. LLMs can help translate vague business requests into coherent user stories, refine them into rigorous specifications, and guide you through complex design patterns. When writing code, they can generate boilerplate faster than you can type, and when reviewing code, they can spot subtle issues you’d miss even after six hours on a caffeine drip.\n\nPerhaps you think your decade of training and expertise will protect you. You’ve survived waves before. But the hard truth is that each successive wave is more powerful, redefining not just your coding tasks but your entire conceptual framework for what it means to develop software. LLMs' productivity gains and competitive pressures are already luring managers, CTOs, and investors. They see the new wave as a way to build high-quality software 3x faster and 10x cheaper without having to deal with diva developers. It doesn’t matter if you dislike it—history doesn’t care. The old ways didn’t stop the shift from assembler to high-level languages, nor the rise of GUIs, nor the transition from mainframes to cloud computing. (For the mainframe-to-cloud shift and its social and economic impacts, see Marinescu, Cloud Computing: Theory and Practice, 3nd ed..)\n\nWe’ve been here before. The arrogance. The denial. The sense of superiority. The belief that “real developers” don’t need these newfangled tools.\n\nArrogance never stopped a tsunami. It only ensured you’d be found face-down after it passed.\n\nThis is a call to arms—my plea to you. Acknowledge that LLMs are not a passing fad. Recognize that their imperfections don’t negate their brute-force utility. Lean in, learn how to use them to augment your capabilities, harness them for analysis, design, testing, code generation, and refactoring. Prepare yourself to adapt or prepare to be swept away, fighting for scraps on the sidelines of a changed profession.\n\nI’ve seen it before. I’m telling you now: There’s a tsunami coming, you can hear a faint roar, and the water is already receding from the shoreline. You can ride the wave, or you can drown in it. Your choice.\n\n\n\nAddendum\n\nMy goal for this essay was to light a fire under complacent software developers. I used drama as a strategy. The essay was a collaboration between me, LibreOfice, Grammarly, and ChatGPT o1. I was the boss; they were the workers. One of the best things about being old (I'm 76) is you \"get comfortable in your own skin\" and don't need external validation. I don't want or need recognition. Feel free to file the serial numbers off and repost it anywhere you want under any name you want.",
    "subreddit": "SoftwareEngineering",
    "upvote_ratio": 0.87,
    "subreddit_type": "public",
    "ups": 2651,
    "downs": 0,
    "created_utc": 1734474747.0,
    "media": null,
    "is_video": false,
    "num_comments": 936,
    "num_reports": null,
    "over_18": false,
    "category": "value-add",
    "category_confidence": 0.72,
    "category_rationale": "Presents a central claim that LLMs will transform software development with supporting reasoning.",
    "composite_score": 5.561943315176625
  },
  {
    "score": 505,
    "title": "can someone explain why we ditched monoliths for microservices? like... what was the reason fr?",
    "selftext": "okay so i’ve been reading about software architecture and i keep seeing this whole “monolith vs microservices” debate.\n\nlike back in the day (early 2000s-ish?) everything was monolithic right? big chunky apps, all code living under one roof like a giant tech house.\n\nbut now it’s all **microservices this, microservices that**. like every service wants to live alone, do its own thing, have its own database\n\nso my question is… **what was the actual reason for this shift?** was monolith THAT bad? what pain were devs feeling that made them go “nah we need to break this up ASAP”?\n\ni get the that there is scalability, teams working in parallel, blah blah, but i just wanna understand the *why* behind the change.\n\nsomeone explain like i’m 5 (but like, 5 with decent coding experience lol). thanks!",
    "subreddit": "SoftwareEngineering",
    "upvote_ratio": 0.95,
    "subreddit_type": "public",
    "ups": 505,
    "downs": 0,
    "created_utc": 1745043168.0,
    "media": null,
    "is_video": false,
    "num_comments": 253,
    "num_reports": null,
    "over_18": false,
    "category": "other",
    "category_confidence": 0.58,
    "category_rationale": "Primarily a request for explanation about monolith vs microservices shift.",
    "composite_score": 4.619067375149768
  },
  {
    "score": 259,
    "title": "Can someone explain to me why TDD isn't a joke?",
    "selftext": "I've been reading up on unit testing, and I was reminded of the existence of TDD. I could never for the life of me take it seriously. But apparently it has a swarm of supporters who I struggle to believe actually adhere to it as much as they say they do. I'm not even sure if people follow it properly, because in TDD you're supposed to write your test, then code to pass the test, ONE TEST A TIME.\n\nBut even if i write all my tests before implementation, imo TDD is at best, just as good as implementing before testing.\n\nTests will inevitably depend on implementation. The first thing you learn about unit testing is edge cases. That's not a \"behavior\" or \"interface\", that's an implementation detail.\n\nUnless the problem you're solving is so simple that you can see ahead of time how the code will look like, you'll inevitably refactor your code as you write it. This means renaming, changing arguments, method &amp; class deletion/creation. That means rewriting your tests as well. That's wasted time.\n\nI think there's value in testing, but doing it backwards makes no sense to me.",
    "subreddit": "SoftwareEngineering",
    "upvote_ratio": 0.81,
    "subreddit_type": "public",
    "ups": 259,
    "downs": 0,
    "created_utc": 1712029731.0,
    "media": null,
    "is_video": false,
    "num_comments": 241,
    "num_reports": null,
    "over_18": false,
    "category": "value-add",
    "category_confidence": 0.6,
    "category_rationale": "Offers reasoning about the value and limitations of TDD, presenting a personal mental model.",
    "composite_score": 4.214381030961033
  },
  {
    "score": 203,
    "title": "How to deal with engineers who just want to push code",
    "selftext": "Team member adds me to a PR.\n\nI leave some comments.\n\n\"I'll address that in another a PR\".\n\nAnother PR never gets raised.\n\nTeam member adds me to another PR.\n\nI leave some more comments about refactoring code we've touched.\n\n\"Can we please not fixate on minor details like that, let's move forward, please approve\".\n\nEtc etc \n\nAt first I planned to just stop reviewing his code but I don't like that solution because it burdens my other team members. I also planned to bring it up with my manager but I'm worried it might negatively affect the general atmosphere of the team - so I don't want to resort to that just yet.\n\nIs there anything else I can do to help my team member be more receptive to code reviews and not just want to get code merged asap?\n\nEDIT: some people were asking for an example about one of my comments. An example is a 50 line code block that is copy and pasted and I'm asking him to put it in a documented function and reuse it in both places.",
    "subreddit": "SoftwareEngineering",
    "upvote_ratio": 0.94,
    "subreddit_type": "public",
    "ups": 203,
    "downs": 0,
    "created_utc": 1698333177.0,
    "media": null,
    "is_video": false,
    "num_comments": 291,
    "num_reports": null,
    "over_18": false,
    "category": "playbook",
    "category_confidence": 0.56,
    "category_rationale": "Requests actionable strategies to improve code reviews and team dynamics.",
    "composite_score": 4.247321593150108
  },
  {
    "score": 188,
    "title": "How do software engineers with years in the industry do comments?",
    "selftext": "Hello, I'm currently working on a project as part of my computer science  program's capstone or project. I'm interested in understanding how experienced  engineers typically use comments within their code. That would be helpful for senior developers or project managers when  reviewing, critiquing, or understanding the code.\n\nI know my code is terrible would like to know some tips for improvements\n\nhttps://preview.redd.it/jpbrxlk62i4c1.png?width=864&amp;format=png&amp;auto=webp&amp;s=8ecc19af99fc74eb4a6e0d1ddeab51ccb7bb77c8",
    "subreddit": "SoftwareEngineering",
    "upvote_ratio": 0.95,
    "subreddit_type": "public",
    "ups": 188,
    "downs": 0,
    "created_utc": 1701792351.0,
    "media": null,
    "is_video": false,
    "num_comments": 291,
    "num_reports": null,
    "over_18": false,
    "category": "other",
    "category_confidence": 0.55,
    "category_rationale": "Simple question about how experienced engineers use comments.",
    "composite_score": 4.221653229897454
  },
  {
    "score": 176,
    "title": "Is submitting WIP as PR an abuse of the PR system?",
    "selftext": "I'm a senior dev with 15+ years of experience. However this is my first time really being the tech lead on a team since most of my work has been done solo or as just a non-lead member of a team. So I'm looking for opinions on whether I'm overreacting to something that one of my teammates keeps doing.\n\nI have a relatively newly hired mid-level dev on my team who regularly creates PRs into the develop branch with code that doesn't even compile. His excuse is that these are WIPs and he's just trying to get feedback from the team on it.\n\nMy opinion is that the intention of a PR is to submit code that is, as much as can be determined, production ready. A PR is no place to submit WIP.\n\nI'm curious as to what the consensus is? Is submitting WIP as a PR an abuse of the PR system? Or do people think it's okay to use the PR in order to get team feedback? To be fair, I can see how the PR *does* package up the diffs all nice and tidy in one place, so it's a tempting tool for that. But I'm wondering if there's a better way to go about this.\n\nGenuinely curious to hear how people fall on this.\n\nEdit: Thank you all for all of the quick feedback. It seems like a lot of people are okay with a PR having WIP as long as it's marked as a draft. I didn't realize this is a thing, and our source control (Bitbucket) *does* have this feature. So I will work with my guy to start marking his PRs as drafts if he wants to get feedback before submitting as a full-on PR. I think this is a great compromise.\n\nThanks all for the responses!",
    "subreddit": "SoftwareEngineering",
    "upvote_ratio": 0.86,
    "subreddit_type": "public",
    "ups": 176,
    "downs": 0,
    "created_utc": 1749152534.0,
    "media": null,
    "is_video": false,
    "num_comments": 45,
    "num_reports": null,
    "over_18": false,
    "category": "value-add",
    "category_confidence": 0.6,
    "category_rationale": "Analyzes best-practice guidance for PRs and argues about when drafts are appropriate.",
    "composite_score": 3.724352182202594
  },
  {
    "score": 174,
    "title": "Do You All Really Think Scrum Is Useless? [Scrum Master Q]",
    "selftext": "In a Scrum Master role at a kinda known large-sized public firm, leading a group of about 15 devs.\n\nI cannot for the life of me get anyone to care about any of the meetings we do.\n\nOur backlog is full of tickets - so there is no shortage of work, but I still cannot for the life of me get anyone to \"buy in\"\n\nDaily Scrum, Sprint planning, and Retrospectives are silent, so I'm just constantly begging the team for input.\n\nIf I call on someone, they'll mumble something generic and not well thought out, which doesn't move the group forward in any way.\n\nSince there's no feedback loop, we constantly encounter the same issues and seemingly have an ever-growing backlog, as most of our devs don't complete all their tickets by sprint end.\n\nWhile I keep trying to get scrum to work over and over again, I'm wondering if I'm just fighting an impossible battle.\n\nDo devs think scrum is worth it? Does it provide any value to you?\n\n-- edit --\n\nFor those dming and asking, we do scrum like this (nothing fancy):\n\n[How We Do Scrum ](https://thedigitalprojectmanager.com/projects/pm-methodology/scrum-ceremonies-made-simple/?utm=oam)",
    "subreddit": "SoftwareEngineering",
    "upvote_ratio": 0.9,
    "subreddit_type": "public",
    "ups": 174,
    "downs": 0,
    "created_utc": 1723775321.0,
    "media": null,
    "is_video": false,
    "num_comments": 393,
    "num_reports": null,
    "over_18": false,
    "category": "rant",
    "category_confidence": 0.62,
    "category_rationale": "Expresses frustration with Scrum and questions its value, signaling emotional stance.",
    "composite_score": 4.215786159599081
  },
  {
    "score": 168,
    "title": "Which CS Topic Gave You That “Mind-Blown” Moment?",
    "selftext": "I’m a staff-level software engineer and I absolutely LOVE reading textbooks.\n\nIt’s partially because they improve my intuition for problem solving, but mostly because it’s so so satisfying to understand how some of these things work. \n\nMy current top 4 “most satisfying” topics/reads:\n\n1. Virtualization, Concurrency and Persistence (Operating Systems, 3 Easy Pieces)\n\n2. Databases &amp; Distributed Systems (Designing Data-Intensive Applications)\n\n3. How the Internet Works (Computer Systems, 6th edition)\n\n4. How Computers Work (The Elements of Computing Systems)\n\nQuestion for you:\n\nWhich CS topic (book, lecture, paper—anything) was the most satisfying to learn, and did it actually level-up your day-to-day engineering?\n\nDrop your pick—and why—below. I’ll compile highlights so everyone gets a fresh reading list. \n\nThanks!",
    "subreddit": "SoftwareEngineering",
    "upvote_ratio": 0.99,
    "subreddit_type": "public",
    "ups": 168,
    "downs": 0,
    "created_utc": 1745769829.0,
    "media": null,
    "is_video": false,
    "num_comments": 73,
    "num_reports": null,
    "over_18": false,
    "category": "other",
    "category_confidence": 0.55,
    "category_rationale": "Asks for opinions on a CS topic and aims to compile a reading list.",
    "composite_score": 3.9050025644791617
  },
  {
    "score": 167,
    "title": "35 years a Software Engineer Today",
    "selftext": "35 years ago today I started my first job as a software engineer at McDonnell-Douglas in St. Louis.  \n\n\nWhite shirt with a tie, dress pants, pocket protector. Paper resumes sent to employers by mail. $26K to start. Cellphones didn't exist. Presentation were given using overhead projectors. PCs were still using MS-DOS. Windows was a novelty program on PCs. The public internet did not yet exist. Our work computers were shared VAXs which we accessed with amber VT-220 terminals. Security posters on the wall telling us \"Don't feed the Bear\". And we wrote Tomahawk cruise missile flight software in Ada, never thinking that it would ever actually be used. And laser targeting systems for the missiles. The factories in the next buildings had production lines for four different fighter aircraft. Reagan's Star Wars projects were being actively pursued - there was a R&amp;D particle beam weapon experiment being developed in the next room to be carried on the space shuttle.",
    "subreddit": "SoftwareEngineering",
    "upvote_ratio": 0.98,
    "subreddit_type": "public",
    "ups": 167,
    "downs": 0,
    "created_utc": 1675927724.0,
    "media": null,
    "is_video": false,
    "num_comments": 85,
    "num_reports": null,
    "over_18": false,
    "category": "other",
    "category_confidence": 0.65,
    "category_rationale": "Staff-era retrospective narrative without advice or instructions.",
    "composite_score": 3.9275585073476464
  },
  {
    "score": 140,
    "title": "Agile is an excuse for poor planning?",
    "selftext": "I am a backend dev with 5 yr of exp. Recently, I was tasked to plan out a new project and I said let’s figure out the data model. I sat with the client and put together about 100 tables within half a working day. Everyone is disagreeing with this method because it ‘halts’ dev time. I have had the grief of maintaining a few projects that are taking years because of this pure agile mindset I feel. We kept doing table migrations that could’ve been avoided if we planned upfront instead of starting with 1 table and scaling up to 50. Tbh these should’ve been shipped out within a year imo\n\nPlease tell me I’m not crazy. I’m not sure where the beef is. \n\nEdit: I’m well aware 100 tables is a lot for that time period *typically*. I should’ve clarified that the clients have data modelling exp and knew the system in and out. Plus a lot of those tables were very simple. Apart from two minor revisions, we pretty much had it down from this session.\n\nI still believe at least a week should be used to get down as much of the data model down before starting dev work. \n\nEdit: Yes, the model was reviewed after the half day by others. We identified it was the simplest design in terms of reducing complex queries, preventing null values and optimizing storage. \n\nEdit: Apart from adding nice-to-haves, the core features of the system will **not** change.",
    "subreddit": "SoftwareEngineering",
    "upvote_ratio": 0.88,
    "subreddit_type": "public",
    "ups": 140,
    "downs": 0,
    "created_utc": 1743163503.0,
    "media": null,
    "is_video": false,
    "num_comments": 167,
    "num_reports": null,
    "over_18": false,
    "category": "value-add",
    "category_confidence": 0.62,
    "category_rationale": "Presents a reasoned critique of agile planning and argues for upfront design.",
    "composite_score": 3.9218737535183115
  },
  {
    "score": 110,
    "title": "Don’t return NULL",
    "selftext": "I’m planning on delivering a tech talk to my team on the pitfalls of explicitly returning nulls in production code, as opposed to using optionals where the language supports it or throwing exceptions when the value is expected to be present. \n\nTo make sure I’m not presenting an overly biased view, and to avoid getting blind-sided if someone raises a point I hadn’t considered, I want to hear examples of times you would actually prefer to explicitly return null. \n\nEdit: Since some were curious and I neglected to specify, our team works predominantly in Java so we do have the Optional interface available to us. \nI have also worked with Go a bit and tbf I did like the ability to have multiple return values in the case of errors etc.\nI also don’t mind how Swift/Kotlin handle optionals and unwrapping them, I believe they handle it in a similar way. ",
    "subreddit": "SoftwareEngineering",
    "upvote_ratio": 0.83,
    "subreddit_type": "public",
    "ups": 110,
    "downs": 0,
    "created_utc": 1710352966.0,
    "media": null,
    "is_video": false,
    "num_comments": 141,
    "num_reports": null,
    "over_18": false,
    "category": "value-add",
    "category_confidence": 0.75,
    "category_rationale": "Explains the rationale and tradeoffs of returning null vs using optionals in code.",
    "composite_score": 3.7439671509781856
  },
  {
    "score": 111,
    "title": "How Instagram Saved 90% of Computing Power &amp; Improved Video Quality",
    "selftext": "With **2.5 billion active users**, **Instagram** is one of the most popular social media platforms in the world.\n\nAnd **video** accounts for **over 80%** of its total traffic.\n\nWith those numbers, it's difficult to imagine how much **computation time and resources** it takes to upload, encode and publish videos from all those users.\n\nBut Instagram managed to reduce that time by 94% and also **improve their video quality**.\n\nHere's how.\n\n# The Process from Upload to Publish\n\nHere are the typical steps that take place whenever a user uploads a video on Instagram:\n\n1. **Pre-processing:** Enhance the video’s quality like color, sharpness, frame rate, etc.\n2. **Compression/Encoding:** Reduce the file size\n3. **Packaging:** Splitting it into smaller chunks for streaming\n\nFor this article, we will focus on the **encoding** and **packaging** steps.\n\n***Sidenote: Video Encoding***\n\n*If you were to record a 10-second 1080 video on your phone without any compression, it would be around* ***1.7 GB***.\n\n*That’s a lot!*\n\n*To make it smaller your phone uses something called a* ***codec***, that compresses the video for storage using ***efficient algorithms***.\n\n*So efficient that it will get the file size down to* ***35MB***, but it's in a format that not designed to be read by humans.\n\n*To watch the encoded video, a* ***codec*** *needs to decompress the file to pixels that can be displayed on your screen.*\n\n*The compression process is called* ***encoding***\\*, and the decompression process is called\\* ***decoding***.\n\n***Codecs*** *have improved over time so there are* [*many of them out there*](https://developer.mozilla.org/en-US/docs/Web/Media/Formats/Video_codecs#common_codecs)*. And they’re stored in most devices, cameras, phones, computers, etc.*\n\nInstagram generated **two types** of encodings on upload: **Advanced Encoding** (AV1), and **Simple** **Encoding** (H.264).\n\n[Screenshot of video from the original article](https://preview.redd.it/7etfqjqhzfhd1.jpg?width=772&amp;format=pjpg&amp;auto=webp&amp;s=70b1fadae1d662d54b5d1982670cde1dcfd67a1e)\n\n**Advanced encoding** produces videos that are small in size with **great quality.** These kind of videos only made up **15% of Instagram’s total watch time**.\n\n**Simple encoding** produces videos work on **older devices,** but used a **less efficient method of compression**, meaning the video are small with not great quality.\n\nTo make matters worse, simple encoding alone took up more than **80% of Instagram's computing resources**.\n\n# Why Simple Encoding Is Such a Resource Hog\n\nFor **Simple encoding**, a video is actually encoded in **two formats**:\n\n* **Adaptive bit rate (ABR)**: video quality will change based on the user's **connection speed.**\n* **Progressive**: video quality **stays the same** no matter the connection. This was for older versions of Instagram that **don't support ABR.**\n\nBoth **ABR** and **Progressive** created multiple encodings of the same video in different **resolutions and bit rates**.\n\nBut for **progressive**, the video player will only play one encoded video.\n\nWhile for **ABR** those videos are split into **small 2-10 second chunks**, and the video player will change which chunk is played based on the user’s internet speed.\n\n[It’s unknown how many videos were produced so 8 is a rough guess](https://preview.redd.it/lsuayeinzfhd1.png?width=5940&amp;format=png&amp;auto=webp&amp;s=d683a04ee913c7a1c49fccf7a49b48e60823e948)\n\n***Sidenote: Bit rate***\n\n*When a video is encoded, it stores binary data (1s and 0s) for each frame of the video, the more information each frame has, the higher its* ***bit rate***.\n\n*If I recorded a video of a still pond the* ***compression algorithm*** *will notice that most pixels stay blue, and store them with* ***less data*** *to keep the pixels the same.*\n\n*If I had a recording of a* ***fast-flowing waterfall*** *and the compression algorithm kept pixels the same, the video would look odd.*\n\n*Since pixels change a lot between frames it needs to* ***store more information*** *in each frame.*\n\n***Bit rate*** *is measured in* ***megabits per second (mbps)*** *since this is how much data is sent to the video player.*\n\n*On YouTube the average bitrate for a 1080 video is* ***8Mbps*** *which is* ***1Mb*** *of transmitted data every second.*\n\nIf you had to guess which specific process was taking up the most resources, you'd correctly guess **adaptive bit rate**.\n\nThis is not only due to creating multiple video files, but also because the additional **packaging step** involves **complex algorithms** to figure out how to **seamlessly switch between different video qualities**.\n\n# The Clever Fix\n\nUsually, progressive encoding creates just one video file. But because Instagram was **creating multiple files** with the same codec as ABR (H.264).\n\nThey realized they could use the **same files for progressive and ABR** eliminating the need to create two sets of the same videos.\n\nhttps://preview.redd.it/o84508otzfhd1.png?width=4911&amp;format=png&amp;auto=webp&amp;s=a3f6d4c6b3ffc89e7d24de1bb3b9ff1c38ea62fe\n\nIf you compare the image above to the previous image, you’ll see that **4 videos** are now created during the encoding stage **instead of 8**.\n\nThe team were able to use **the same progressive files** for the packaging stage of ABR which wasn’t as efficient as before resulting in **poorer compression**.\n\nBut they did save **a lot of resources**.\n\nInstagram claims the old ABR process took **86 seconds** for a **23-second video**.\n\nBut the **new** ABR process, just packaging, took **0.36 seconds**, which is a whopping **99% reduction** in processing time.\n\nWith this much reduction Instagram could dedicate more resources to the **advanced encoding process**, which meant more users could see **higher quality videos**. How?\n\nBecause simple encoding **took longer** in the old process and used **more resources**, there wasn’t enough to always create advanced videos.\n\nWith the new process, there was enough resource to run **both types of encoding**, meaning both can be published and more users would see **higher quality videos**.\n\nThis resulted in an increase in views of advanced encoded video **from 15% to 48%**.\n\n[Image from original article](https://preview.redd.it/zo9kjcqwzfhd1.jpg?width=1157&amp;format=pjpg&amp;auto=webp&amp;s=746017c9f57784ae541540cea7ef9e790c7ffcaa)\n\n***Sidenote: Encoding vs Transcoding***\n\n*This is an optional side note for the video experts among you.*\n\n*The word* ***transcoding*** *isn't used in this article, but technically it should have been.*\n\n***Encoding*** *is the process of compressing an uncompressed video into a smaller format.*\n\n***Transcoding*** *is the process of changing a video from one encoded format to the same, or another format.*\n\n*Because all devices (phones, cameras) have a* ***codec***\\*, when a video is recorded it is automatically encoded.\\*\n\n*So even before you upload a video to* ***Instagram*** *it is already encoded, and any further encoding is called* ***transcoding***.\n\n*But because the* [*original article*](https://engineering.fb.com/2022/11/04/video-engineering/instagram-video-processing-encoding-reduction/) *mostly uses the term* ***encoding*** *and it’s is such a catch-all term used in the industry, I decided to stick with it.*\n\n# Wrapping Things Up\n\nAfter reading this you may be thinking, **how did the team not spot this obvious improvement?**\n\nWell, small issues on a small scale are often **overlooked**. Small issues on a large scale **no longer remain small issues**, and I guess that's what happened here.\n\nBesides, Instagram was always a **photo app** that is now focusing more on video, so I assume it's a learning process for them too.\n\nIf you want to read **more about their learnings,** check out the [Meta Engineering Blog](https://engineering.fb.com/tag/instagram/).\n\nBut if you enjoyed this **simplified version**, be sure to [subscribe](https://newsletter.betterstack.com/).",
    "subreddit": "SoftwareEngineering",
    "upvote_ratio": 0.97,
    "subreddit_type": "public",
    "ups": 111,
    "downs": 0,
    "created_utc": 1723123949.0,
    "media": null,
    "is_video": false,
    "num_comments": 7,
    "num_reports": null,
    "over_18": false,
    "category": "listicle",
    "category_confidence": 0.72,
    "category_rationale": "Enumerates a finite set of steps in a process (pre-processing, encoding, packaging).",
    "composite_score": 3.2282630161661534
  },
  {
    "score": 89,
    "title": "What are some subtle screening questions to separate serious software engineers from code monkeys?",
    "selftext": "I need to hire a serious software engineer who applies clean code principles and thinks about software architecture at a high level. I've been fooled before. What are some specific non- or semi-technical screening questions I can use to quickly weed out unsuitable candidates before vetting them more thoroughly?\n\nHere's one example: \"What do you think of functional programming?\" The answer isn't important per se, but if a candidate doesn't at least know what functional programming \\*is\\* (and many don't), he or she is too junior for this role. (I'm fine with a small risk of eliminating a good candidate who somehow hasn't heard the term.)",
    "subreddit": "SoftwareEngineering",
    "upvote_ratio": 0.67,
    "subreddit_type": "public",
    "ups": 89,
    "downs": 0,
    "created_utc": 1716320489.0,
    "media": null,
    "is_video": false,
    "num_comments": 161,
    "num_reports": null,
    "over_18": false,
    "category": "value-add",
    "category_confidence": 0.72,
    "category_rationale": "Offers screening questions and reasoning to improve interviewing outcomes.",
    "composite_score": 3.56150001671064
  },
  {
    "score": 73,
    "title": "Does Scrum actually suck, or are we just doing it wrong?",
    "selftext": "I just read this [article,](https://thenewstack.io/scrum-sucks-because-youre-doing-it-wrong/) and it really made me think about all the hate Scrum gets. A lot of the problems people have with it seem to come down to how it’s being used (or misused). Like, it’s not supposed to be about micromanaging or cramming too much into a sprint—it’s about empowering teams and delivering value.\n\nThe article does a good job of breaking down how Scrum can go off the rails and what it’s actually meant to do. Honestly, it gave me a fresh perspective.\n\nCurious to hear how others feel about this—is it a broken system, or are we just doing it wrong?\n",
    "subreddit": "SoftwareEngineering",
    "upvote_ratio": 0.86,
    "subreddit_type": "public",
    "ups": 73,
    "downs": 0,
    "created_utc": 1733871808.0,
    "media": null,
    "is_video": false,
    "num_comments": 155,
    "num_reports": null,
    "over_18": false,
    "category": "value-add",
    "category_confidence": 0.65,
    "category_rationale": "Provides perspective on Scrum usage and its intended purpose with analysis.",
    "composite_score": 3.6107940189082073
  },
  {
    "score": 76,
    "title": "Is It Really Possible To Be A 10X Engineer?",
    "selftext": "Hi!  \n\n\nI was recently watching Silicon Valley, specifically the part for the \"Woman Engineer\" scene, where Richard and Jared interview a female for a possible role at Pied Piper, and how she was an engineering lead in her previous roles at startups, etc. For comedic effect, Jard becomes too obsessed with \"hiring the best that happens to be a woman, but being a woman won't have any effect on the decision making, but it would be nice if that person is a woman\" thing. You can see the clip here, [https://www.youtube.com/watch?v=Dek5HtNdIHY](https://www.youtube.com/watch?v=Dek5HtNdIHY).  \n\n\nI was just wondering, listening to the actors talk in praise of another engineer, if is it possible for someone to grow exponentially and have a lot under their belt in a smaller period, for a person to be a \"10X Engineer\", to grow immensely, have immense work to show and be a vital contributor to where you work. Why, and why not? What do you think about this?  \n\n\nThanks!",
    "subreddit": "SoftwareEngineering",
    "upvote_ratio": 0.86,
    "subreddit_type": "public",
    "ups": 76,
    "downs": 0,
    "created_utc": 1678048891.0,
    "media": null,
    "is_video": false,
    "num_comments": 81,
    "num_reports": null,
    "over_18": false,
    "category": "other",
    "category_confidence": 0.58,
    "category_rationale": "Poses a broad question about the feasibility of being a 10X engineer with minimal substantive content.",
    "composite_score": 3.48839765136434
  },
  {
    "score": 74,
    "title": "Coding practices at Google and Microsoft vs. startups",
    "selftext": "Hey, I recently sat together with Michael Lynch, an ex-Googler and ex-Microsoftie who now runs his own tech start-up, Tiny Pilot.   \n\n\nI asked him about software engineering practices at Google and Microsoft and how they differ from what he now does at his own start-up. We are both code review fans, so we also talked about this engineering practice.  \n\n\nIn a nutshell, he stressed that at Google and Microsoft, you write code that has to be supported for many, many years. In a start-up, you might not even know if the code will ever have customers. So, quality concerns are totally different.    \n\n\nHe also said that in a start-up, as a technical founder, you do not have to convince anybody to pay back technical debt. It's at your own discretion. So moving fast at the beginning is not such a problem.  \n\n\nStill, at his own start-up, he does code reviews, also to mentor his contractors and to ensure the code is maintainable and consistent. And he also writes tests.   \n\n\nBut he does all of that always with an eye on the return on investment, which we should also do in other settings.\n\nSo, if it's too hard to write that unit test, he writes an integration test. And if he sees manual testing is sufficient at the moment, he does not write tests.  \n\n\nI found the conversation very interesting and insightful. If you want to listen to it, you can check it out here: [https://www.software-engineering-unlocked.com/coding-practices-maang/](https://www.software-engineering-unlocked.com/coding-practices-maang/)",
    "subreddit": "SoftwareEngineering",
    "upvote_ratio": 0.95,
    "subreddit_type": "public",
    "ups": 74,
    "downs": 0,
    "created_utc": 1674118240.0,
    "media": null,
    "is_video": false,
    "num_comments": 32,
    "num_reports": null,
    "over_18": false,
    "category": "value-add",
    "category_confidence": 0.72,
    "category_rationale": "Describes differences in practices at large tech companies vs startups with reasoning.",
    "composite_score": 3.346818233330644
  },
  {
    "score": 68,
    "title": "Dealing with stigma as a software engineer",
    "selftext": "I’ve had many traditional engineers tell me that my work is too easy and that it’s not even real engineering. They write a few scripts and some C programs and then boast that they are now “software engineers” too. I try to explain to them how hard and technical our interview process is, how hard exams and projects are in a CS degree but they are never convinced.\nPreviously I was able to say that we have astronomically higher salaries but now with the recent layoffs they gloat even more over how “unnecessary” and over hired we are.\nIt’s to the point where I have almost started to feel ashamed as a software engineer and the fact that my company just had layoffs also doesn’t help \n\nSorry for the rant, was looking to see if anybody else here has similar experiences",
    "subreddit": "SoftwareEngineering",
    "upvote_ratio": 0.84,
    "subreddit_type": "public",
    "ups": 68,
    "downs": 0,
    "created_utc": 1681978976.0,
    "media": null,
    "is_video": false,
    "num_comments": 117,
    "num_reports": null,
    "over_18": false,
    "category": "rant",
    "category_confidence": 0.85,
    "category_rationale": "Expresses frustration about stigma and layoffs in the software engineering field.",
    "composite_score": 3.5047900943903176
  },
  {
    "score": 61,
    "title": "Other engineer disciplines ask me to stop calling myself a engineer - discussion",
    "selftext": "Going throw this out to the group for opinions.\n\nI work for a product development company, (with electronic engineers, firmware engineers). \n\nThere seams to be mounting pressure that I stop calling myself a software engineer, (change it to software developer).\nAs they feel \"I'm not a real engineer\".\n\nI'm not particularly attached to the title, whatever really. But I've had the title in other companies, (and the done the architect work, hold the ethics and use the applied principles required of it) hence I list it on my linkedin and introduce myself as such etc. \nI've also worked with software engineers that feel very strongly about their title.\n\nWhat's the groups thoughts on this, should I just change it and who cares? Would you change it if asked yourself? Or have another opinion?\n\nEdit: Based in Australia, and yes engineers can be certified with a regulatory board called Engineers Australia. However you can't register as a software engineer. Even with a software engineer degree.",
    "subreddit": "SoftwareEngineering",
    "upvote_ratio": 0.91,
    "subreddit_type": "public",
    "ups": 61,
    "downs": 0,
    "created_utc": 1678815181.0,
    "media": null,
    "is_video": false,
    "num_comments": 180,
    "num_reports": null,
    "over_18": false,
    "category": "other",
    "category_confidence": 0.6,
    "category_rationale": "Discusses opinions on job titles without substantial actionable content.",
    "composite_score": 3.6037309769328463
  },
  {
    "score": 59,
    "title": "SOLID is not solid. Balancing tradeoffs usually requires domain knowledge.",
    "selftext": "I've tried to collect what you might call algorithms to objectively judge code for fitting SOLID principles, and cannot find anything that is universally agreed upon. Looking at examples and scenarios others give for the application of SOLID, I usually see that too many unbacked assumptions are made.\n\nThe most common problem is assumptions about how the needs (requirements) will change in the future. Without knowing the domain, nobody actually knows.  There are almost **no free-lunches** in the SOLID principles; they all make assumptions. If you believe I'm incorrect, please list the free lunches.\n\nIt reminds of the time OOP proponents said \"most case statements are bad, use sub-classing instead\". The typical example showed how much easier it is to add a sub-type. While technically correct, it makes it harder to do other things, such as adding a new operation (method) to existing sub-types. Which one is less code change depends on actual future code changes, which are either unknown, or depend on domain knowledge to know. (\"C family\" languages have a horrible case statement syntax, so probably not the best language to score code change impact on. Sub-classing also assumes things change in a tree-shaped way. They often don't in practice.)\n\nSome are almost free-lunches, but still have catches. For example, let's take ISP: The Interface Segregation Principle: \"Clients should not be forced to depend upon interfaces that they do not use.\"\n\nThat's a specific case of \"avoid unnecessary dependencies\". That is usually good advice, but scoring \"unnecessary\" usually makes domain assumptions also. If one ends up having to often change which features a given object has access to, then it may just be better to give it easy access to all the relevant libraries. \"Isolating\" something usually requires effort to de-isolate when relationships are later needed: it's not a free lunch. The level/distance of isolation (modulization) should generally depend on the likelihood of future relationship needs of the domain.\n\nThere are coders who stick Dependency Injection (DI) everywhere \"in case\". It can make for bloated round-about code. [YAGNI](https://en.wikipedia.org/wiki/You_aren%27t_gonna_need_it) would dictate don't create a DI interface unless you are likely to actually need it, or wait until you actually do need it. Don't get DI-happy. When does YAGNI override DI and vice versa? Well, it depends. It *aallll* depends.\n\nThe devil's in the details: balancing the tricky trade-offs involved, and knowing the domain. There are no cookie-cutter principles that allow you to skip proper analysis. **There are rules of thumb, but they usually conflict with other rules of thumb**, just like how DI conflicts with YAGNI. How does one settle the conflicts? Well, *it depends.*\n\n\\[Subject to editing\\]",
    "subreddit": "SoftwareEngineering",
    "upvote_ratio": 0.91,
    "subreddit_type": "public",
    "ups": 59,
    "downs": 0,
    "created_utc": 1682547025.0,
    "media": null,
    "is_video": false,
    "num_comments": 58,
    "num_reports": null,
    "over_18": false,
    "category": "value-add",
    "category_confidence": 0.78,
    "category_rationale": "Analyses SOLID principles and the role of domain knowledge in tradeoffs.",
    "composite_score": 3.346077256204716
  },
  {
    "score": 58,
    "title": "AITA for stalemating a code review",
    "selftext": "I am an embedded firmware engineer in a very small team of 3 developers. When I started 8 months ago, I added a pipeline job to require one other developer's approval before code can be merged. One developer, Bob really didn't like this as it was not his usual flow. \n\nRecently, Bob requested that I review his Merge Request as the other dev, Tom, was on vacation. Typically, Bob has Tom review his code changes, since, in Bob's own words, \"He's basically a rubber stamp\", but with Tom out he would need my approval.\n\n* On Tuesday after 5pm, he requested a review.\n* On Wednesday morning, I provided two pieces of input. \n\n1. \"Do we really need to force kill module A in this case? I think our process monitor will handle it already.\"\n2. \"The .gitmodules change looks accidental\"\n\nTo my surprise, Bob implemented comment 1 and fixed comment 2.\n\n* On Friday at 4pm, Bob notified me that it was again ready for review, but that it was still building (our pipeline builds currently take 2 hours)\n* At 4:30, I left 1 comment\n\n**Me**: \"So I'm looking through the code on your MR. Can we reduce the level of indentation here. When it gets to about 4 or 5 levels of indentation it becomes unmanageable. I understand a lot of our codebase has an insane amount of indentation but I have never seen 14 levels of indentation.\"\n\n**Bob**: \"It works. I could split it out as a function, but doesn't seem worth it as this point. That will cause another half-day delay.\"\n\n**Me**: \"I know our code base is not that clean, but I want to create a more readable codebase and I believe that we can do better than this.\nUnfortunately, code is read way more than it is written and I don't feel comfortable merging this until the readability is improved.\"\n\n**Bob**: \"I disagree. The functionality is clear. In my opinion, it is not your job as a reviewer to critique coding style. It is to confirm there are no errors. The goal is to have functional code. It has been thoroughly tested. To make any major changes at this point, without any changes in functionality will result in excessive delays in releasing this.\"\n\n**Me**: \"As a reviewer, my responsibility is not just to confirm the absence of errors but also to ensure that the code is readable and maintainable.\nI understand your concerns about the delay, but investing the time now in readability can save us a lot of time and effort in the long run. This code will live on in currentRevision, eventually currentRevisionV2, and we can fix it later, but it will be easier and quicker to solve it now.\"\n\n* At this point it’s 5:00pm so I log off\n\n\n**Bob**: \"I disagree.”\n\n**30 minutes elapse**\n\n**Bob**: \"It's also your responsibility to work amicably with your coworkers\"\n\nAt this point, it’s 6:00pm and as I’m cooking dinner, I’m trying to figure out how to resolve this so I decide to straight out ask Bob what I have done that is bothering him so much. I’m somewhat second guessing myself. Maybe, I am being too dictatorial, on simple style issues, but where do you draw the line? In my opinion, merging in code with 14 levels of indentation is not a simple style issue, it is like planting a landmine in the codebase. If this code causes issues in the future, I will feel partially responsible if I just approve it. I feel like Bob is trying to strongarm me into just shipping it. I'm wondering if this is a hill worth dying on.\n\nI have had a similar argument in the past during a code review when Bob wanted to merge in Dead Zombie Code (code that had been functionally removed, but was just commented out). He didn’t want to completely remove it in case we needed it later and he didn’t trust our version control to bring it back if we wanted to. Eventually, he gave in to my protests and removed that commented out code. In that case, to him, it was style semantics, to me it was fundamentally wrong.\n\nUnfortunately these days, I spend a good chunk of my time resolving old bugs introduced by Bob and refactoring unreadable code written by Bob. But for every 25 lines I fix, Bob introduces 200 new lines with the same old issues. Things like, copy pasting code instead of breaking it out into a function, dereferencing objects without checking if they're Null, adding log statements at INFO level that should really be at TRACE level. When he says that his code is tested, there is no test report or unit tests, it's really just a \"Trust me Bro, it worked on my machine\". So, it feels like all my efforts are quickly wiped out by Bob.\n\nStrangely, I never have these issues with Tom. So I don't think my code reviews are exceptionally harsh. In fact, my bar for approval is simply don't make things worse. Tom just writes better code.\n\nWith all this in mind I asked Bob,\n\n**Me**: \"What about my behavior has been unamicable?\"\n\n**Bob**: \"You're not listening to what I have to say and you seem to be dictating changes. That is not the role of a reviewer, in my opinion. This whole interaction is very off-putting. \n\n**30 minutes elapse**\n\n**Bob**: \"Look, you're a very smart guy, and I do appreciate your input. But that's what it is... input. If what you have to say sounds reasonable, I will make the changes. But I can't have you dictating changes. That's not your job as a reviewer.\"\n\n**30 minutes elapse**\n\n**Bob**: \"Transferred MR to Tom\"\n\nNow, after all this strife, the code will simply be rubber stamped by Tom when he returns to work on Monday. \n\nI do not want to be dictating semantic style changes, but it is unclear to me where the line is for this style is so bad it may as well be a mistake. \nIn the code there was a couple lines like,\n\n    if conditionA or conditionB:\n        if conditionA:  \n            #doSomething  \n\nThat is just insanely wrong to me and lazy.\nTo Bob, it works.\n\n* Sunday at Noon (I have not said anything to Bob since Friday when I asked \"What about my behavior has been unamicable?\")\n\n* **Bob**: \"After some reflection, this interchange was very upsetting and humiliating. I don't care to go through that again. Probably not use you for code reviews in the future.\"\n\nSo\n\n* AITA for stalemating this code review?\n* What should I do come Monday?\n* Should I bring in Tom, line managers, or HR to have a discussion?\n\nEDIT: We currently do not have a linter in the pipeline or a style guide.\n\nThe code in question looked like\n\n    if\n        if\n            if\n                if\n                    if\n                        if\n                            if\n                                if\n                                    if\n                                        if\n                                            if\n                                                if\n                                                    if\n                                                        if\n                                                            if\n                                                                hisCodeHere\n\nEDIT2:\n\n* The language is python.\n* Bob has been in his role for at least 6 years. He would be considered a senior.\n\nBob has sent out the following email,\n\nHi lineManager and productManager,\n&gt; I would like to be clear on what the job of a merge reviewer is. My understanding is that it is to catch any problems in logic or errors in coding. DarkMarker is refusing to approve my merge because he doesn't like my indentation. This is a style issue. This has been thoroughly tested code. To do what he wants will result in at least a day if not more delay... not just the coding change but all facets of testing. Please advise me on how I should proceed. I'm very unhappy on how this code review has been handled. This isn't the only one. I will prefer Tom going forward.\nThanks\nBob\n\n\nEDIT3: \n\nTo be clear there were 10 levels of nested conditionals already existing in the code snippet. \n\nBob added 4 new nested conditionals.\n\nThere are no unit tests, there is no test report, there are no logs from a manual test. \n\nI made a mistake of not bundling all my review into the first code review. I didn’t catch the nesting on the first go around because gitlab diffs default to side by side. This hides the level of nesting. On the second code review, I checked out his branch and noticed the insane level of nesting. I should have done that the first review. \n\nThis sprint there is already a task to implement SonarQube. \n\nOur unit test pipeline job has 6 unit tests. \n\nI agree, a MR is probably not the place to start enforcing this kind of thing. I think approval + refactor ticket + a comment about this level of nesting is probably a better path\n\nEDIT 4: I appreciate all the feedback and will definitely apply it going forward. \n\nThe update for those who were wondering is below. \n\n* Tom merged Bob’s MR on Monday. \n* Bob skipped stand up on Monday Morning. \n* Line Manager is Out of the Office this week on work travel. \n* Line manager requested via email to see how bad the code was after receiving the email from Bob. I sent him the code snippets along side my concerns and mistakes I think I made in discussing with Bob (failure to communicate it is not a style issue but a nesting complexity issue, failure to do a thorough MR first code review, missing the opportunity to approve with a comment and a debt ticket.\n* Line manager said he would discuss it with Bob.\n* Bob sent me a rude message on Monday night at 10:00pm belittling a major feature I implemented 2 months ago. I have not talked to him since Friday. \n\nThe larger context of the post that I have intentionally left out (because I want to improve my soft skills and ability to work with Bob) is that management finds Bob difficult and does not like working with him. \n\nThey are aware that Bob generates a ton of bugs, bad code, and often misremembers how our product works. Bob has released multiple production breaking bugs in the last few months. Bugs that break core features of our product. \nBob is just as argumentative and defensive when these critical bugs are found in the field. He says they are not replicatable, even when the replication steps are \n\n1. Use the product as is expected.\n\nSince he is so difficult to deal with and basically will not acknowledge the bug’s existence, management will have me root cause and resolve the issue. Bob ends up sheltered away and does not have to experience the consequences of his buggy code. \n\nThey are also aware that our developer flow needs improvement and are actively prioritizing these things in the backlog and into sprints (Reducing build time, Linter in Pipeline, automated integration tests on live hardware, etc).\n\nSo long story short, things are quiet right now, but I would say I have management in my corner.",
    "subreddit": "SoftwareEngineering",
    "upvote_ratio": 0.84,
    "subreddit_type": "public",
    "ups": 58,
    "downs": 0,
    "created_utc": 1682270344.0,
    "media": null,
    "is_video": false,
    "num_comments": 75,
    "num_reports": null,
    "over_18": false,
    "category": "rant",
    "category_confidence": 0.7,
    "category_rationale": "Recounts a code-review stalemate with emotional framing and moral questions.",
    "composite_score": 3.34125880778254
  },
  {
    "score": 54,
    "title": "A Software Engineer’s Guide to Observability (Intro + Logging)",
    "selftext": "At Blueground we’ve been rethinking observability from the ground up. Instead of just buying tools, we wanted to set principles and practices that scale across dozens of teams.\n\nWe’ve started a blog series to document the journey:\n\n* The [intro post](https://engineering.theblueground.com/a-software-engineers-guide-to-observability/) explains why observability matters now, the gaps we faced, and what the series will cover (logging, metrics, tracing, dashboards, SLOs, etc).\n* [Part 1 (Logging)](https://engineering.theblueground.com/a-software-engineers-guide-to-observability-part-1-logging/) dives into concrete lessons:\n   * Logs are primarily for troubleshooting, not alerting.\n   * Standardization across teams is invaluable.\n   * Good logs provide the right context and will increasingly serve AI systems as much as humans.\n\nI’d love to hear how others approach this, do you enforce logging schemas and policies, or let each team handle it their own way?",
    "subreddit": "SoftwareEngineering",
    "upvote_ratio": 0.95,
    "subreddit_type": "public",
    "ups": 54,
    "downs": 0,
    "created_utc": 1758107487.0,
    "media": null,
    "is_video": false,
    "num_comments": 11,
    "num_reports": null,
    "over_18": false,
    "category": "value-add",
    "category_confidence": 0.72,
    "category_rationale": "Explains observability principles and key takeaways rather than a step-by-step how-to.",
    "composite_score": 2.992453312518056
  },
  {
    "score": 52,
    "title": "Software Development Rule #1 (IMHO): Understand the code...",
    "selftext": "I gave this advice today and thought it would be good to also give it here, just in case it happens to have slipped by anyone...\n\nWhen writing code, expect to be asked the question, \"Why did you do this here?\"...\n\nYour answer should NOT simply be, \"Because it was done that way over there.\" - as the next question you should be asked is, \"Why was it done that way over there?\"...\n\nIf you don't understand the code, don't write it. Ensure that you completely understand the code you are considering writing before copying and pasting or even just mimicking someone else's code - especially if it's from a random website or an AI bot or even if it's inside the very project on which you're working.\n\nThe first step to writing good code is to fully understand the code you're writing; you should never skip that step...",
    "subreddit": "SoftwareEngineering",
    "upvote_ratio": 0.89,
    "subreddit_type": "public",
    "ups": 52,
    "downs": 0,
    "created_utc": 1693435000.0,
    "media": null,
    "is_video": false,
    "num_comments": 45,
    "num_reports": null,
    "over_18": false,
    "category": "value-add",
    "category_confidence": 0.74,
    "category_rationale": "Offers a central claim about understanding code before writing and reasoning to support it.",
    "composite_score": 3.223154785441576
  },
  {
    "score": 51,
    "title": "\"Service\" layer becoming too big. Do you know another architecture with one more layer ?",
    "selftext": "Hi\n\nIn my team, we work on several projects using this classical architecture with 3 layers: Controller/Service/Repository.\n\nControllers contains endpoints, handle http responses\nServices contain the business logic, transform the daga\nRepositories retrieves the data from db\n\nFor the Controllers and Repositories it works very well: we keep these files very clean and short, the methods are straightforward.\n\nBut the issue is with the Services, most of our services are becoming very big files, with massive public methods for each business logic, and lots of private helper methods of course.\n\nWe are all already trying to improve that, by trying to extract some related methods to a new Service if the current one becomes too big,  by promoting Helper or Util classes containing reusable methods, etc.\n\nAnd the solution that worked best to prevent big files: by using linger rules that limit the number of methods in a single file before allowing the merge of a pull request.\n\nBut even if we try, you know how it is... Our Services are always filled to the top of the limit, and the projects are starting to have many Services for lot of sub-logic. For example:\n\nAccountService which was enough at the beginning is now full so now we have many other services like CurrentAccountService, CheckingAccountService, CheckingAccountLinkService, CheckingAccountLinkToWithdrawService, etc etc...\n\nThe service layer is becoming a mess.\n\n I would like to find some painless and \"automatic\" way to solve this issue.\n\nMy idea would be to introduce a new kind of layer, this layer would be mandatory in the team and would permit to lighten the Service layer.\n\nBut what could this layer do ?\nWould the layer be between Controller and Service or beween Service and Repository ?\n\nAnd most important question, have you ever heard of such architecture in any framework in general, with one more layer to lighten the Service layer ?\n\nI don't want to reinvent the wheel, maybe some well tested architecture already exists.\n\nThanks for your help",
    "subreddit": "SoftwareEngineering",
    "upvote_ratio": 0.98,
    "subreddit_type": "public",
    "ups": 51,
    "downs": 0,
    "created_utc": 1743544263.0,
    "media": null,
    "is_video": false,
    "num_comments": 47,
    "num_reports": null,
    "over_18": false,
    "category": "other",
    "category_confidence": 0.55,
    "category_rationale": "Primarily a discussion prompt about architecture with no concrete model or steps.",
    "composite_score": 3.2916239623225927
  },
  {
    "score": 50,
    "title": "Update regarding the blackout",
    "selftext": "After much thought, I've decided to open the sub again, it's not fair to contributors to hold the content hostage; Reddit is doubling down on their API stance, and they are forcing mods out of subs and reverting what we do, I'm following advice from a coordinated mod effort to reach out to news outlets and making noise, sadly, the blackout didn't work.\n\nI wish the initial push was for an indefinite blackout, but just locking communities for two days wasn't going to hurt much, and in the end is people searching for information that are being locked out of it. \n\nI invite users to stop using Reddit as much as they can, search for alternative communities, I'm still figuring out what the best way to have a decentralized alternative is, I'm leaning towards Lemmy, and I'll invite everyone to join as soon as there is something available.",
    "subreddit": "SoftwareEngineering",
    "upvote_ratio": 0.73,
    "subreddit_type": "public",
    "ups": 50,
    "downs": 0,
    "created_utc": 1687288666.0,
    "media": null,
    "is_video": false,
    "num_comments": 56,
    "num_reports": null,
    "over_18": false,
    "category": "rant",
    "category_confidence": 0.85,
    "category_rationale": "Emotional critique and stance about Reddit policy with a call to action.",
    "composite_score": 3.133007603934182
  },
  {
    "score": 49,
    "title": "What was the tech industry like in the 90s?",
    "selftext": "I'm 27 years of age and have worked at 3 scale-up tech companies since graduating. Each time I've moved companies I've hoped for greener grass, better organisation, more competent executives, but for the most part I see massive overlap in issues faced. It's worth noting that I've only experienced smaller companies, 100+ employees, typically funded and not profitable. \n\nAdherence to scrum  is of huge annoyance to me. to me it's one of those things that work well in theory but never in practise. Having to abide by principles and engage in planning, ceremonies seem like a huge waste of developer time and often disengaging. \n\nI'm curious to hear from older folk who have been in the industry for a long time. Having seen how disorganised tech companies can be, I'm inspired by the folks who worked on milestones such as Microsoft, Apple software, etc. \n\nWe're things simpler back in the day w.r.t. autonomy? Have product owners always been a thing? If so, did these folk typically come from technical backgrounds? Did priorities always get shaped by dedicated product teams or were engineers empowered to make these call s? \n\nI'm not trying to slate these individual functions, but I sometimes wonder what the outcome of allowing a competent engineering team to self-organise whilst following some north star.",
    "subreddit": "SoftwareEngineering",
    "upvote_ratio": 0.95,
    "subreddit_type": "public",
    "ups": 49,
    "downs": 0,
    "created_utc": 1683325177.0,
    "media": null,
    "is_video": false,
    "num_comments": 42,
    "num_reports": null,
    "over_18": false,
    "category": "other",
    "category_confidence": 0.6,
    "category_rationale": "A reflective discussion question about the tech industry without actionable guidance.",
    "composite_score": 3.2282042321258118
  }
]